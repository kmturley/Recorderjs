<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Recorder.js Loop</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
</head>
<body>
    <h1>Backing</h1>
    <a href="#" id="play">Play</a>
    <a href="#" id="stop">Stop</a>
    <h1>Vocals</h1>
    <a href="#" id="record">Record</a>
    <a href="#" id="recordStop">Record Stop</a>
    <a href="#" id="play2">Play</a>
    <a href="#" id="stop2">Stop</a>
    <p>Offset <input type="range" min="-500" max="0" value="-150" id="offset" step="25" /> <span id="offsetTotal">-150</span>ms</p>
    <div id="player"></div>
    
    <script src="recorder.js"></script>
    <script>
        /**
         * Web audio record
         * by kmturley
         **/

        var module = {
            /**
             * @method init
             */
            init: function () {
                var me = this;

                window.onload = function () {
                    try {
                        window.AudioContext = window.AudioContext || window.webkitAudioContext  || window.mozAudioContext || window.msAudioContext;
                        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
                        window.URL = window.URL || window.webkitURL || window.mozURL  || window.msURL;
                        me.context = new window.AudioContext();
                        me.context.createGain = me.context.createGain || me.context.createGainNode;
                    } catch (e) {
                        window.alert('Your browser does not support WebAudio, try Google Chrome');
                    }

                    if (navigator.getUserMedia) {
                        navigator.getUserMedia({audio: true}, function (stream) {
                            var input = me.context.createMediaStreamSource(stream);
                            me.recorder = new Recorder(input);
                        }, function (e) {
                            window.alert('Please enable your microphone to begin recording');
                        });
                    } else {
                        window.alert('Your browser does not support recording, try Google Chrome');
                    }
                };
            },
            /**
             * @method cue
             */
            cue: function (url, callback) {
                console.log('player.cue', url);
                var me = this;
                if (this.request) {
                    this.request.abort();
                } else {
                    this.request = new XMLHttpRequest();
                }
                this.request.open('GET', url, true);
                this.request.responseType = 'arraybuffer';
                this.request.onload = function () {
                    console.log('player.cue.complete');
                    me.context.decodeAudioData(me.request.response, function (buffer) {
                        callback(buffer);
                    });
                };
                this.request.send();
            },
            /**
             * @method play
             */
            play: function (data) {
                console.log('player.play', this.context.currentTime, data);
                var me = this,
                    source = this.context.createBufferSource(),
                    gainNode = this.context.createGain();
                if (!source.start) { source.start = source.noteOn; }
                if (!source.stop) { source.stop = source.noteOff; }
                source.connect(gainNode);
                gainNode.connect(this.context.destination);
                source.buffer = data;
                source.loop = true;
                source.startTime = this.context.currentTime;
                source.start(0);
                console.log('player.play.duration', source.duration);
                return source;
            },
            /**
             * @method stop
             */
            stop: function (source) {
                console.log('player.stop', this.context.currentTime);
                if (source) {
                    source.stop(0);
                }
            },
            /**
             * @method record
             */
            record: function () {
                console.log('player.record', this.context.currentTime);
                // should start time be recorded before or after the record function?
                this.recorder.record();
                this.recorder.startTime = this.context.currentTime;
            },
            /**
             * @method record
             */
            recordStop: function (callback) {
                var me = this;
                console.log('player.recordStop', this.context.currentTime);
                this.recorder.stop();
                this.recorder.stopTime = this.context.currentTime;
                this.recorder.getBuffer(function (buffers) {
                    callback(buffers, me.recorder.startTime, me.recorder.stopTime);
                    me.recorder.clear();
                });
            },
            /**
             * @method convertBuffer
             */
            convertBuffer: function (buffers, before, after) {
                console.log('player.convertBuffer', buffers, before, after);
                var i = 0,
                    channel = 0,
                    offset = 0,
                    beforeLength = Math.round(before * this.context.sampleRate),
                    afterLength = Math.round(after * this.context.sampleRate),
                    audioBuffer = this.context.createBuffer(2, beforeLength, this.context.sampleRate),
                    audioBuffer2 = this.context.createBuffer(2, buffers[0].length, this.context.sampleRate),
                    audioBuffer3 = this.context.createBuffer(2, afterLength, this.context.sampleRate),
                    audioBuffer4 = this.context.createBuffer(2, beforeLength + buffers[0].length + afterLength, this.context.sampleRate),
                    buffer = null,
                    buffer2 = null,
                    buffer3 = null,
                    buffer4 = null;
                
                //console.log('player.convertBuffer', beforeLength, buffers[0].length, afterLength);
                
                // fill the gaps before and after the recording with white noise
                for (channel = 0; channel < 2; channel += 1) {
                    buffer = audioBuffer.getChannelData(channel);
                    buffer2 = audioBuffer2.getChannelData(channel);
                    buffer3 = audioBuffer3.getChannelData(channel);
                    buffer4 = audioBuffer4.getChannelData(channel);
                    for (i = 0; i < beforeLength; i += 1) {
                        buffer[offset] = 0; //Math.random() - 0.5;
                        buffer4[offset] = 0; //Math.random() - 0.5;
                        offset += 1;
                    }
                    for (i = 0; i < buffers[channel].length; i += 1) {
                        buffer2[offset] = buffers[channel][i];
                        buffer4[offset] = buffers[channel][i];
                        offset += 1;
                    }
                    for (i = 0; i < afterLength; i += 1) {
                        buffer3[offset] = 0; //Math.random() - 0.5;
                        buffer4[offset] = 0; //Math.random() - 0.5;
                        offset += 1;
                    }
                }
                
                // compare the result of the original and the filled versions
                console.log('player.convertBuffer before', audioBuffer);
                console.log('player.convertBuffer middle', audioBuffer2);
                console.log('player.convertBuffer after', audioBuffer3);
                console.log('player.convertBuffer all', audioBuffer4);
                
                return audioBuffer4;
            }
        };

        /* example additional code */

        var offset = -150,
            start = 0,
            stop = 0,
            backing = null,
            backingInstance = null,
            vocals = null,
            vocalsBuffers = null,
            vocalsInstance = null;

        module.init();
        
        function calculateOffset() {
            var num = start - backingInstance.startTime + (offset / 1000),
                before = num % backing.duration,
                after = backing.duration - ((num + (stop - start)) % backing.duration);
            console.log('calculateOffset', backing.duration, (stop - start), before, after, offset);
            return module.convertBuffer(vocalsBuffers, before, after);
        }

        document.getElementById('play').addEventListener('click', function () {
            module.cue('90bpm.mp3', function (file) {
                backing = file;
                backingInstance = module.play(backing);
            });
        });

        document.getElementById('stop').addEventListener('click', function () {
            module.stop(backingInstance);
        });

        document.getElementById('record').addEventListener('click', function () {
            module.record();
        });
        
        document.getElementById('recordStop').addEventListener('click', function () {
            module.recordStop(function (buffers, startTime, stopTime) {
                vocalsBuffers = buffers;
                start = startTime;
                stop = stopTime;
            });
        });
        
        document.getElementById('play2').addEventListener('click', function () {
            if (!vocals) {
                vocals = calculateOffset();
            }
            vocalsInstance = module.play(vocals);
        });

        document.getElementById('stop2').addEventListener('click', function () {
            module.stop(vocalsInstance);
        });
        
        document.getElementById('offset').addEventListener('change', function (e) {
            offset = e.target.value;
            document.getElementById('offsetTotal').innerHTML = e.target.value;
            vocals = calculateOffset();
        });
    </script>
</body>
</html>
